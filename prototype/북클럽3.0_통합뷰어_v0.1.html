<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<title>ë¶í´ëŸ½ 3.0 í†µí•© ë·°ì–´ ì—”ì§„ v0.1</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;-webkit-tap-highlight-color:transparent}
html,body,#root{width:100%;height:100%;overflow:hidden;background:#fff}
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const {useState,useEffect,useRef,useCallback,useReducer,useMemo} = React;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SHARED UTILITY â€” Flood Fill (Canvas)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function floodFill(canvas, ctx, startX, startY, fillHex, tolerance = 40) {
  const dpr = window.devicePixelRatio || 1;
  const W = canvas.width, H = canvas.height;
  const imgData = ctx.getImageData(0, 0, W, H);
  const d = imgData.data;
  const px = Math.floor(startX * dpr), py = Math.floor(startY * dpr);
  if (px < 0 || px >= W || py < 0 || py >= H) return;
  const idx0 = (py * W + px) * 4;
  const tR = d[idx0], tG = d[idx0+1], tB = d[idx0+2], tA = d[idx0+3];
  const hex = fillHex.replace('#','');
  const fR = parseInt(hex.substr(0,2),16), fG = parseInt(hex.substr(2,2),16), fB = parseInt(hex.substr(4,2),16);
  if (tR === fR && tG === fG && tB === fB) return;
  const match = i => Math.abs(d[i]-tR)<=tolerance && Math.abs(d[i+1]-tG)<=tolerance && Math.abs(d[i+2]-tB)<=tolerance && Math.abs(d[i+3]-tA)<=tolerance;
  const stk = [[px, py]], vis = new Uint8Array(W * H);
  while (stk.length) {
    const [cx, cy] = stk.pop();
    if (cx < 0 || cx >= W || cy < 0 || cy >= H) continue;
    const pi = cy * W + cx;
    if (vis[pi]) continue;
    const i = pi * 4;
    if (!match(i)) continue;
    vis[pi] = 1; d[i] = fR; d[i+1] = fG; d[i+2] = fB; d[i+3] = 255;
    stk.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
  }
  ctx.putImageData(imgData, 0, 0);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SWIPE HOOK â€” Pointer Events (í„°ì¹˜ + ë§ˆìš°ìŠ¤ í†µí•©)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function useSwipe(onLeft, onRight, { onDragStart, onTap } = {}) {
  const startX = useRef(0);
  const startY = useRef(0);
  const dragging = useRef(false);
  const hasMoved = useRef(false);
  const offset = useRef(0);
  const [dx, setDx] = useState(0);

  const onPointerDown = useCallback(e => {
    // ë²„íŠ¼/ì…ë ¥ ìš”ì†ŒëŠ” ì œì™¸
    if (e.target.closest('button, input, textarea, [data-no-swipe]')) return;
    startX.current = e.clientX;
    startY.current = e.clientY;
    dragging.current = true;
    hasMoved.current = false;
    offset.current = 0;
    setDx(0);
    e.target.setPointerCapture?.(e.pointerId);
  }, []);

  const onPointerMove = useCallback(e => {
    if (!dragging.current) return;
    const diffX = e.clientX - startX.current;
    const diffY = e.clientY - startY.current;
    // ìˆ˜í‰ ì´ë™ì´ ìˆ˜ì§ë³´ë‹¤ í´ ë•Œë§Œ ìŠ¤ì™€ì´í”„ë¡œ ì¸ì‹
    if (Math.abs(diffX) > Math.abs(diffY) + 5) {
      // ì²˜ìŒ ì›€ì§ì´ê¸° ì‹œì‘í•  ë•Œ UI ìˆ¨ê¹€
      if (!hasMoved.current && Math.abs(diffX) > 10) {
        hasMoved.current = true;
        onDragStart?.();
      }
      offset.current = diffX;
      setDx(diffX);
    }
  }, [onDragStart]);

  const onPointerUp = useCallback(() => {
    if (!dragging.current) return;
    dragging.current = false;
    // ë“œë˜ê·¸ ì—†ì´ íƒ­ë§Œ í•œ ê²½ìš°
    if (!hasMoved.current && Math.abs(offset.current) < 10) {
      onTap?.();
    } else {
      if (offset.current < -60) onLeft();
      else if (offset.current > 60) onRight();
    }
    offset.current = 0;
    setDx(0);
  }, [onLeft, onRight, onTap]);

  const onPointerCancel = useCallback(() => {
    dragging.current = false;
    hasMoved.current = false;
    offset.current = 0;
    setDx(0);
  }, []);

  return {
    dx,
    handlers: {
      onPointerDown,
      onPointerMove,
      onPointerUp,
      onPointerCancel,
      style: { touchAction: 'pan-y' }, // ìˆ˜ì§ ìŠ¤í¬ë¡¤ì€ í—ˆìš©, ìˆ˜í‰ì€ JSê°€ ì²˜ë¦¬
    }
  };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FULLSCREEN UTIL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function requestFS(el) {
  if (!el) return;
  if (el.requestFullscreen) el.requestFullscreen();
  else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  else if (el.msRequestFullscreen) el.msRequestFullscreen();
}
function exitFS() {
  if (document.exitFullscreen) document.exitFullscreen();
  else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
  else if (document.msExitFullscreen) document.msExitFullscreen();
}
function useFullscreen(ref) {
  const [isFS, setIsFS] = useState(false);
  useEffect(() => {
    const h = () => setIsFS(!!(document.fullscreenElement || document.webkitFullscreenElement));
    document.addEventListener('fullscreenchange', h);
    document.addEventListener('webkitfullscreenchange', h);
    return () => {
      document.removeEventListener('fullscreenchange', h);
      document.removeEventListener('webkitfullscreenchange', h);
    };
  }, []);
  const toggle = useCallback(() => {
    if (isFS) exitFS(); else requestFS(ref.current);
  }, [isFS, ref]);
  return { isFS, toggle };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PDF BOOK VIEWER â€” pdf.js canvas rendering
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function PDFBookViewer({ fileData, fileName, onExit }) {
  const [pdfDoc, setPdfDoc] = useState(null);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [uiVisible, setUiVisible] = useState(true);
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  const renderTaskRef = useRef(null);
  const [subMode, setSubMode] = useState(null);   // null | 'write' | 'gallery'
  const [capturedPage, setCapturedPage] = useState(null);
  const [editingReport, setEditingReport] = useState(null);
  const [toastMsg, setToastMsg] = useState(null);
  const [viewMode, setViewMode] = useState('single'); // 'single' | 'spread'
  const [autoPlay, setAutoPlay] = useState(false);
  const [autoSpeed, setAutoSpeed] = useState(3);
  const canvas2Ref = useRef(null);
  const renderTask2Ref = useRef(null);
  const autoTimerRef = useRef(null);

  const captureCurrentPage = useCallback(() => {
    if (canvasRef.current) return canvasRef.current.toDataURL('image/png');
    return null;
  }, []);

  const handleScreenCapture = useCallback(() => {
    const dataUrl = captureCurrentPage();
    if (!dataUrl) return;
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = `${fileName || 'page'}_${page}p.png`;
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    setToastMsg('ì €ì¥ ì™„ë£Œ!');
    setTimeout(() => setToastMsg(null), 1800);
  }, [captureCurrentPage, fileName, page]);

  const handleStartWrite = useCallback(() => {
    setEditingReport(null);
    setCapturedPage(captureCurrentPage());
    setSubMode('write');
  }, [captureCurrentPage]);

  const handleOpenGallery = useCallback(() => {
    setSubMode('gallery');
  }, []);

  const handleEditFromGallery = useCallback((report) => {
    setEditingReport(report);
    setSubMode('write');
  }, []);

  // Load PDF document
  useEffect(() => {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    pdfjsLib.getDocument({ data: new Uint8Array(fileData) }).promise
      .then(doc => {
        setPdfDoc(doc);
        setTotalPages(doc.numPages);
        setLoading(false);
      })
      .catch(() => setError('PDF íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'));
  }, [fileData]);

  // Render page(s) to canvas â€” single & spread support
  const renderOnePage = useCallback((pageNum, canvasEl, availW, ch) => {
    if (!pdfDoc || !canvasEl) return null;
    return pdfDoc.getPage(pageNum).then(p => {
      const ctx = canvasEl.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const vp0 = p.getViewport({ scale: 1 });
      const fitScale = Math.min(availW / vp0.width, ch / vp0.height);
      const vp = p.getViewport({ scale: fitScale * dpr });
      canvasEl.width = vp.width;
      canvasEl.height = vp.height;
      canvasEl.style.width = (vp.width / dpr) + 'px';
      canvasEl.style.height = (vp.height / dpr) + 'px';
      const task = p.render({ canvasContext: ctx, viewport: vp });
      task.promise.catch(() => {});
      return task;
    });
  }, [pdfDoc]);

  useEffect(() => {
    if (!pdfDoc || loading || !canvasRef.current || !containerRef.current) return;

    // ì»¨í…Œì´ë„ˆ ë ˆì´ì•„ì›ƒì´ ì™„ë£Œëœ í›„ ë Œë”ë§ (requestAnimationFrameìœ¼ë¡œ ë‹¤ìŒ í”„ë ˆì„ ëŒ€ê¸°)
    const frameId = requestAnimationFrame(() => {
      const cw = containerRef.current?.clientWidth;
      const ch = containerRef.current?.clientHeight;
      if (!cw || !ch) return;

      try { renderTaskRef.current?.cancel(); } catch(e) {}
      try { renderTask2Ref.current?.cancel(); } catch(e) {}

      const isSpread = viewMode === 'spread';
      const availW = isSpread ? (cw / 2 - 4) : cw;

      renderOnePage(page, canvasRef.current, availW, ch)
        .then(task => { renderTaskRef.current = task; });

      if (isSpread && page + 1 <= totalPages && canvas2Ref.current) {
        renderOnePage(page + 1, canvas2Ref.current, availW, ch)
          .then(task => { renderTask2Ref.current = task; });
      }
    });

    return () => cancelAnimationFrame(frameId);
  }, [pdfDoc, loading, page, viewMode, totalPages, renderOnePage]);

  // Keyboard nav
  useEffect(() => {
    const h = e => {
      if (e.key === 'ArrowRight') goNext();
      else if (e.key === 'ArrowLeft') goPrev();
      else if (e.key === 'Escape') onExit();
    };
    window.addEventListener('keydown', h);
    return () => window.removeEventListener('keydown', h);
  });

  const goNext = useCallback(() => {
    const step = viewMode === 'spread' ? 2 : 1;
    setPage(p => Math.min(p + step, totalPages));
  }, [totalPages, viewMode]);
  const goPrev = useCallback(() => {
    const step = viewMode === 'spread' ? 2 : 1;
    setPage(p => Math.max(p - step, 1));
  }, [viewMode]);
  const hideUI = useCallback(() => setUiVisible(false), []);
  const toggleUI = useCallback(() => setUiVisible(v => !v), []);
  const { dx, handlers } = useSwipe(goNext, goPrev, { onDragStart: hideUI, onTap: toggleUI });

  // Auto-play timer
  useEffect(() => {
    if (autoPlay && !loading) {
      autoTimerRef.current = setInterval(() => {
        setPage(prev => {
          const step = viewMode === 'spread' ? 2 : 1;
          const next = prev + step;
          if (next > totalPages) { setAutoPlay(false); return prev; }
          return next;
        });
      }, autoSpeed * 1000);
    } else {
      clearInterval(autoTimerRef.current);
    }
    return () => clearInterval(autoTimerRef.current);
  }, [autoPlay, autoSpeed, totalPages, viewMode, loading]);

  // Ensure odd page in spread mode
  const handleViewModeChange = useCallback((mode) => {
    if (mode === 'spread') {
      setPage(p => p % 2 === 0 ? Math.max(1, p - 1) : p);
    }
    setViewMode(mode);
    setAutoPlay(false);
  }, []);

  if (error) return (
    <div className="w-full h-full flex flex-col items-center justify-center gap-4">
      <span className="text-red-500 text-lg">{error}</span>
      <button onClick={onExit} className="px-4 py-2 rounded-lg bg-gray-100 text-sm">ëŒì•„ê°€ê¸°</button>
    </div>
  );

  if (loading) return (
    <div className="w-full h-full flex flex-col items-center justify-center bg-gray-50">
      <div className="w-8 h-8 border-2 border-gray-300 border-t-gray-700 rounded-full animate-spin mb-3" />
      <span className="text-sm text-gray-500">PDF ë¡œë”© ì¤‘...</span>
    </div>
  );

  const visualDx = Math.max(-120, Math.min(120, dx)) * 0.4;

  const { style: swipeStyle, ...swipeHandlers } = handlers;

  return (
    <div className="w-full h-full relative select-none cursor-grab active:cursor-grabbing"
         {...swipeHandlers}
         style={swipeStyle}>

      {/* Canvas area */}
      <div ref={containerRef}
           className="absolute inset-0 flex items-center justify-center bg-gray-100 overflow-hidden">
        <div className="flex items-center gap-1 transition-transform"
             style={{ transform: `translateX(${visualDx}px)`, transitionDuration: dx === 0 ? '0.3s' : '0s' }}>
          <canvas ref={canvasRef} className="shadow-lg" />
          {viewMode === 'spread' && page + 1 <= totalPages && (
            <canvas ref={canvas2Ref} className="shadow-lg" />
          )}
        </div>
      </div>

      {/* Top bar */}
      <div className={`absolute top-0 inset-x-0 z-20 transition-all duration-300
        ${uiVisible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-full pointer-events-none'}`}>
        <div className="flex items-center justify-between px-5 py-3 bg-white/80 backdrop-blur border-b border-gray-100">
          <button onClick={e => { e.stopPropagation(); onExit(); }}
                  className="w-10 h-10 rounded-lg bg-gray-100 flex items-center justify-center text-lg active:scale-95 transition-transform">â†</button>
          <span className="text-sm font-semibold text-gray-700 truncate max-w-[180px]">{fileName}</span>
          <span className="text-xs text-gray-400 min-w-[56px] text-right">
            {viewMode === 'spread' && page + 1 <= totalPages ? `${page}-${page+1}` : page} / {totalPages}
          </span>
        </div>
      </div>

      {/* Arrow buttons */}
      <div className={`absolute inset-y-0 inset-x-0 z-10 flex items-center justify-between px-3 pointer-events-none
        transition-opacity duration-300 ${uiVisible ? 'opacity-100' : 'opacity-0'}`}>
        {page > 1 ? (
          <button onClick={e => { e.stopPropagation(); goPrev(); }}
                  className="pointer-events-auto w-11 h-11 rounded-full bg-white/80 backdrop-blur border border-gray-200 flex items-center justify-center text-lg text-gray-500 active:scale-95 shadow-sm">â€¹</button>
        ) : <div />}
        {page < totalPages ? (
          <button onClick={e => { e.stopPropagation(); goNext(); }}
                  className="pointer-events-auto w-11 h-11 rounded-full bg-white/80 backdrop-blur border border-gray-200 flex items-center justify-center text-lg text-gray-500 active:scale-95 shadow-sm">â€º</button>
        ) : <div />}
      </div>

      {/* Bottom progress */}
      <div className={`absolute bottom-0 inset-x-0 z-20 transition-all duration-300
        ${uiVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-full pointer-events-none'}`}>
        <div className="py-4 px-5 bg-white/80 backdrop-blur border-t border-gray-100">
          <div className="h-1.5 rounded-full bg-gray-200">
            <div className="h-full rounded-full bg-gray-700 transition-all duration-300"
                 style={{ width: `${(page / totalPages) * 100}%` }} />
          </div>
        </div>
      </div>

      {/* â”€â”€â”€ ë·° ëª¨ë“œ & ìë™ì¬ìƒ íˆ´ë°” â”€â”€â”€ */}
      <div className={`absolute bottom-[7.5rem] inset-x-0 z-20 flex justify-center transition-all duration-300
        ${uiVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-8 pointer-events-none'}`}>
        <div className="flex items-center gap-2 bg-white/90 backdrop-blur rounded-full px-3 py-1.5 shadow-lg border border-gray-200"
             onClick={e => e.stopPropagation()}>
          {/* ë‹¨ë©´ / ì–‘ë©´ */}
          <div className="flex bg-gray-100 rounded-full p-0.5">
            <button onClick={() => handleViewModeChange('single')}
                    className={`px-3 py-1 rounded-full text-[11px] font-semibold transition ${viewMode==='single' ? 'bg-white text-gray-800 shadow-sm' : 'text-gray-400'}`}>
              ë‹¨ë©´
            </button>
            <button onClick={() => handleViewModeChange('spread')}
                    className={`px-3 py-1 rounded-full text-[11px] font-semibold transition ${viewMode==='spread' ? 'bg-white text-gray-800 shadow-sm' : 'text-gray-400'}`}>
              ì–‘ë©´
            </button>
          </div>
          <div className="w-px h-5 bg-gray-200" />
          {/* ìë™ì¬ìƒ */}
          <button onClick={() => setAutoPlay(a => !a)}
                  className={`px-3 py-1 rounded-full text-[11px] font-bold transition active:scale-95 ${autoPlay ? 'bg-green-500 text-white' : 'bg-gray-100 text-gray-600'}`}>
            {autoPlay ? 'â¸ ì •ì§€' : 'â–¶ ìë™ì¬ìƒ'}
          </button>
          {/* ì†ë„ ì„ íƒ */}
          <div className="flex bg-gray-100 rounded-full p-0.5">
            {[2, 3, 5, 8].map(s => (
              <button key={s} onClick={() => setAutoSpeed(s)}
                      className={`px-2 py-1 rounded-full text-[10px] font-bold transition ${autoSpeed===s ? 'bg-white text-gray-800 shadow-sm' : 'text-gray-400'}`}>
                {s}ì´ˆ
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* â”€â”€â”€ ë„ì„œ ë·°ì–´ ì•¡ì…˜ íˆ´ë°” â”€â”€â”€ */}
      <div className={`absolute bottom-16 inset-x-0 z-20 flex justify-center transition-all duration-300
        ${uiVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-8 pointer-events-none'}`}>
        <div className="flex gap-1.5 bg-white/90 backdrop-blur rounded-full px-2 py-1.5 shadow-lg border border-gray-200"
             onClick={e => e.stopPropagation()}>
          <button onClick={handleScreenCapture}
                  className="px-3 py-1.5 rounded-full text-[11px] font-semibold text-gray-600 bg-gray-100 hover:bg-gray-200 active:scale-95 transition flex items-center gap-1">
            ğŸ“¸ ì „ì²´í™”ë©´ì €ì¥
          </button>
          <button onClick={handleStartWrite}
                  className="px-3 py-1.5 rounded-full text-[11px] font-semibold text-white bg-blue-500 hover:bg-blue-600 active:scale-95 transition flex items-center gap-1">
            âœï¸ ê°ìƒë¬¸ì“°ê¸°
          </button>
          <button onClick={handleOpenGallery}
                  className="px-3 py-1.5 rounded-full text-[11px] font-semibold text-gray-600 bg-gray-100 hover:bg-gray-200 active:scale-95 transition flex items-center gap-1">
            ğŸ“– ê°ìƒë¬¸ë³´ê¸°
          </button>
        </div>
      </div>

      {/* Toast notification */}
      {toastMsg && (
        <div className="absolute top-20 inset-x-0 z-50 flex justify-center pointer-events-none">
          <div className="bg-black/80 text-white text-sm font-semibold px-5 py-2.5 rounded-full shadow-lg">
            âœ… {toastMsg}
          </div>
        </div>
      )}

      {/* â”€â”€â”€ Sub-mode overlays â”€â”€â”€ */}
      {subMode === 'write' && (
        <div className="absolute inset-0 z-40" onClick={e => e.stopPropagation()}>
          <ReportWriter
            bookName={fileName}
            pageImageSrc={capturedPage}
            onExit={() => setSubMode(null)}
            existingReport={editingReport}
          />
        </div>
      )}
      {subMode === 'gallery' && (
        <div className="absolute inset-0 z-40" onClick={e => e.stopPropagation()}>
          <ReportGallery
            bookName={fileName}
            onExit={() => setSubMode(null)}
            onEdit={handleEditFromGallery}
          />
        </div>
      )}
    </div>
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VIDEO VIEWER â€” Fullscreen API + Cinematic
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function VideoViewer({ onExit }) {
  const [playing, setPlaying] = useState(true);
  const [time, setTime] = useState(0);
  const [speed, setSpeed] = useState(1.0);
  const [uiVisible, setUiVisible] = useState(true);
  const wrapRef = useRef(null);
  const ivRef = useRef(null);
  const { isFS, toggle: toggleFS } = useFullscreen(wrapRef);

  const DURATION = 180;
  const pct = (time / DURATION) * 100;
  const SPEEDS = [0.5, 1.0, 1.5, 2.0];
  const fmt = s => `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;

  useEffect(() => {
    if (playing) {
      ivRef.current = setInterval(() => {
        setTime(t => {
          const next = t + speed * 0.5;
          if (next >= DURATION) { setPlaying(false); return DURATION; }
          return next;
        });
      }, 500);
    } else {
      clearInterval(ivRef.current);
    }
    return () => clearInterval(ivRef.current);
  }, [playing, speed]);

  return (
    <div ref={wrapRef} className="w-full h-full relative select-none bg-black"
         onClick={() => setUiVisible(v => !v)}>

      {/* Video sim */}
      <div className="absolute inset-0 flex flex-col items-center justify-center bg-gradient-to-br from-indigo-900 via-purple-900 to-slate-900">
        <span className="text-7xl mb-4">ğŸ“º</span>
        <span className="text-white font-bold text-2xl">ë…ì„œì˜ ë§ˆë²•</span>
        <span className="text-white/40 text-sm mt-1">ì‹œë®¬ë ˆì´ì…˜ ì˜ìƒ</span>
        {playing && (
          <div className="flex items-center gap-2 mt-4">
            <div className="w-2.5 h-2.5 bg-red-500 rounded-full animate-pulse" />
            <span className="text-white/70 text-xs">ì¬ìƒ ì¤‘ Â· {speed}x</span>
          </div>
        )}
      </div>

      {/* Top bar */}
      <div className={`absolute top-0 inset-x-0 z-20 transition-all duration-300
        ${uiVisible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-full pointer-events-none'}`}>
        <div className="flex items-center justify-between px-5 py-3 bg-gradient-to-b from-black/60 to-transparent">
          <button onClick={e => { e.stopPropagation(); if (isFS) exitFS(); onExit(); }}
                  className="w-10 h-10 rounded-lg bg-white/15 backdrop-blur flex items-center justify-center text-lg text-white active:scale-95">â†</button>
          <span className="text-sm font-semibold text-white/90">ì˜ìƒ ëª¨ë“œ</span>
          <button onClick={e => { e.stopPropagation(); toggleFS(); }}
                  className="w-10 h-10 rounded-lg bg-white/15 backdrop-blur flex items-center justify-center text-lg text-white active:scale-95">{isFS ? 'âŠ¡' : 'â›¶'}</button>
        </div>
      </div>

      {/* Bottom controls */}
      <div className={`absolute bottom-0 inset-x-0 z-20 transition-all duration-300
        ${uiVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-full pointer-events-none'}`}>
        <div className="bg-gradient-to-t from-black/70 to-transparent pt-10 pb-5 px-5">
          <div className="flex items-center gap-3 mb-4">
            <span className="text-white/60 text-xs font-mono min-w-[36px]">{fmt(time)}</span>
            <div className="flex-1 h-1.5 rounded-full bg-white/20 relative cursor-pointer group"
                 onClick={e => {
                   e.stopPropagation();
                   const r = e.currentTarget.getBoundingClientRect();
                   setTime(Math.max(0, Math.min(DURATION, ((e.clientX - r.left) / r.width) * DURATION)));
                 }}>
              <div className="h-full rounded-full bg-white transition-all" style={{ width: `${pct}%` }} />
              <div className="absolute top-1/2 -translate-y-1/2 w-3.5 h-3.5 bg-white rounded-full shadow opacity-0 group-hover:opacity-100 transition-opacity"
                   style={{ left: `${pct}%`, marginLeft: '-7px' }} />
            </div>
            <span className="text-white/60 text-xs font-mono min-w-[36px] text-right">{fmt(DURATION)}</span>
          </div>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <button onClick={e => { e.stopPropagation(); setTime(t => Math.max(0, t - 10)); }}
                      className="text-white/70 text-xs font-bold active:scale-95 hover:text-white">-10s</button>
              <button onClick={e => { e.stopPropagation(); setPlaying(!playing); }}
                      className="w-12 h-12 rounded-full bg-white/20 backdrop-blur flex items-center justify-center text-xl text-white active:scale-95 hover:bg-white/30">
                {playing ? 'â¸' : 'â–¶'}
              </button>
              <button onClick={e => { e.stopPropagation(); setTime(t => Math.min(DURATION, t + 10)); }}
                      className="text-white/70 text-xs font-bold active:scale-95 hover:text-white">+10s</button>
            </div>
            <div className="flex items-center gap-1">
              {SPEEDS.map(s => (
                <button key={s} onClick={e => { e.stopPropagation(); setSpeed(s); }}
                        className={`px-2.5 py-1 rounded text-[11px] font-bold transition active:scale-95
                          ${speed === s ? 'bg-white text-black' : 'text-white/60 hover:text-white'}`}>{s}x</button>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INTERACTIVE VIEWER â€” ë†€ì´í•™ìŠµ ì¸í„°ë™í‹°ë¸Œ ì½˜í…ì¸  ì—”ì§„
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* --- Demo page definitions --- */
const DEMO_PAGES = [
  { id:1, type:'intro', title:'ë†€ì´í•™ìŠµ ì‹œì‘!', stars:0 },
  { id:2, type:'drag',  title:'ë™ë¬¼ ì¹œêµ¬ë“¤ì˜ ì§‘ ì°¾ê¸°', stars:3 },
  { id:3, type:'color', title:'ë¬´ì§€ê°œ ë‚˜ë¹„ ìƒ‰ì¹ í•˜ê¸°', stars:2 },
  { id:4, type:'match', title:'ê³¼ì¼ ì´ë¦„ ì—°ê²°í•˜ê¸°', stars:3 },
  { id:5, type:'camera',title:'ë‚˜ë§Œì˜ ë¶í´ëŸ½ ì¹´ë©”ë¼', stars:2 },
];

/* --- Activity state reducer --- */
function activityReducer(state, action) {
  switch(action.type) {
    case 'COMPLETE_PAGE': {
      const completed = new Set(state.completed);
      completed.add(action.pageId);
      return { ...state, completed, totalStars: state.totalStars + (action.stars||0) };
    }
    case 'SET_PAGE':
      return { ...state, currentPage: action.page };
    case 'RESET':
      return { completed: new Set(), currentPage: 1, totalStars: 0 };
    default: return state;
  }
}

/* --- Completion Overlay --- */
function CompletionOverlay({ stars, onNext }) {
  const [show, setShow] = useState(false);
  const [starAnims, setStarAnims] = useState([]);

  useEffect(() => {
    setShow(true);
    const timers = [];
    for (let i = 0; i < stars; i++) {
      timers.push(setTimeout(() => {
        setStarAnims(prev => [...prev, i]);
      }, 400 + i * 350));
    }
    return () => timers.forEach(clearTimeout);
  }, [stars]);

  return (
    <div className={`absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/50 backdrop-blur-sm transition-opacity duration-500 ${show ? 'opacity-100' : 'opacity-0'}`}>
      <div className="bg-white rounded-3xl p-8 shadow-2xl flex flex-col items-center gap-4 max-w-xs mx-4 transform transition-transform duration-500" style={{transform: show ? 'scale(1)' : 'scale(0.7)'}}>
        <div className="text-5xl mb-2">ğŸ‰</div>
        <h3 className="text-xl font-bold text-gray-800">ì˜í–ˆì–´ìš”!</h3>
        <div className="flex gap-2">
          {Array.from({length: stars}).map((_, i) => (
            <span key={i} className="text-4xl transition-all duration-500"
                  style={{
                    transform: starAnims.includes(i) ? 'scale(1) rotate(0deg)' : 'scale(0) rotate(-180deg)',
                    opacity: starAnims.includes(i) ? 1 : 0,
                  }}>â­</span>
          ))}
        </div>
        <button onClick={onNext}
                className="mt-2 px-8 py-3 bg-gradient-to-r from-amber-400 to-orange-400 text-white font-bold rounded-full shadow-lg active:scale-95 transition-transform text-sm">
          ë‹¤ìŒìœ¼ë¡œ â†’
        </button>
      </div>
    </div>
  );
}

/* --- Intro Page --- */
function IntroPage({ onComplete }) {
  return (
    <div className="w-full h-full flex flex-col items-center justify-center bg-gradient-to-br from-sky-50 via-white to-amber-50 px-8">
      <div className="text-7xl mb-6 animate-bounce">ğŸ®</div>
      <h2 className="text-2xl font-bold text-gray-800 mb-3">ë†€ì´í•™ìŠµ ì‹œì‘!</h2>
      <p className="text-sm text-gray-500 text-center leading-relaxed mb-2">
        ì¬ë¯¸ìˆëŠ” í™œë™ 4ê°€ì§€ê°€ ê¸°ë‹¤ë¦¬ê³  ìˆì–´ìš”.
      </p>
      <div className="flex flex-col gap-2 mt-4 mb-8 text-sm text-gray-600">
        <div className="flex items-center gap-3"><span className="text-xl">ğŸ¾</span> ë™ë¬¼ ì¹œêµ¬ë“¤ì˜ ì§‘ ì°¾ê¸°</div>
        <div className="flex items-center gap-3"><span className="text-xl">ğŸ¨</span> ë¬´ì§€ê°œ ë‚˜ë¹„ ìƒ‰ì¹ í•˜ê¸°</div>
        <div className="flex items-center gap-3"><span className="text-xl">ğŸ”—</span> ê³¼ì¼ ì´ë¦„ ì—°ê²°í•˜ê¸°</div>
        <div className="flex items-center gap-3"><span className="text-xl">ğŸ“¸</span> ë‚˜ë§Œì˜ ë¶í´ëŸ½ ì¹´ë©”ë¼</div>
      </div>
      <button onClick={onComplete}
              className="px-10 py-4 bg-gradient-to-r from-blue-500 to-indigo-500 text-white font-bold rounded-full shadow-lg active:scale-95 transition-transform text-base">
        ì‹œì‘í•˜ê¸°!
      </button>
    </div>
  );
}

/* --- Drag & Drop Activity --- */
function DragDropActivity({ onComplete }) {
  const ANIMALS = [
    { id:'dog', emoji:'ğŸ•', name:'ê°•ì•„ì§€', target:'house' },
    { id:'fish', emoji:'ğŸŸ', name:'ë¬¼ê³ ê¸°', target:'water' },
    { id:'bird', emoji:'ğŸ¦', name:'ìƒˆ', target:'tree' },
    { id:'rabbit', emoji:'ğŸ°', name:'í† ë¼', target:'burrow' },
  ];
  const ZONES = [
    { id:'house', emoji:'ğŸ ', name:'ì§‘', x:65, y:12 },
    { id:'water', emoji:'ğŸŒŠ', name:'ì—°ëª»', x:65, y:37 },
    { id:'tree', emoji:'ğŸŒ³', name:'ë‚˜ë¬´', x:65, y:62 },
    { id:'burrow', emoji:'ğŸ•³ï¸', name:'êµ´', x:65, y:87 },
  ];

  const containerRef = useRef(null);
  const [items, setItems] = useState(() =>
    ANIMALS.map((a, i) => ({ ...a, x: 15, y: 12 + i * 25, placed: false, correct: false }))
  );
  const [dragging, setDragging] = useState(null);
  const [dragOffset, setDragOffset] = useState({x:0, y:0});
  const [showOverlay, setShowOverlay] = useState(false);

  const toPercent = useCallback((clientX, clientY) => {
    if (!containerRef.current) return {x:0,y:0};
    const r = containerRef.current.getBoundingClientRect();
    return { x: ((clientX - r.left) / r.width) * 100, y: ((clientY - r.top) / r.height) * 100 };
  }, []);

  const handlePointerDown = useCallback((e, itemId) => {
    e.preventDefault();
    e.target.setPointerCapture?.(e.pointerId);
    const pos = toPercent(e.clientX, e.clientY);
    const item = items.find(i => i.id === itemId);
    if (item?.placed) return;
    setDragging(itemId);
    setDragOffset({ x: pos.x - item.x, y: pos.y - item.y });
  }, [items, toPercent]);

  const handlePointerMove = useCallback((e) => {
    if (!dragging) return;
    e.preventDefault();
    const pos = toPercent(e.clientX, e.clientY);
    setItems(prev => prev.map(it =>
      it.id === dragging ? { ...it, x: pos.x - dragOffset.x, y: pos.y - dragOffset.y } : it
    ));
  }, [dragging, dragOffset, toPercent]);

  const handlePointerUp = useCallback(() => {
    if (!dragging) return;
    setItems(prev => {
      const newItems = prev.map(it => {
        if (it.id !== dragging) return it;
        const zone = ZONES.find(z => z.id === it.target);
        const dist = Math.sqrt(Math.pow(it.x - zone.x, 2) + Math.pow(it.y - zone.y, 2));
        if (dist < 15) {
          return { ...it, x: zone.x, y: zone.y, placed: true, correct: true };
        }
        const orig = ANIMALS.findIndex(a => a.id === it.id);
        return { ...it, x: 15, y: 12 + orig * 25 };
      });
      const allDone = newItems.every(i => i.placed);
      if (allDone) {
        setTimeout(() => setShowOverlay(true), 500);
      }
      return newItems;
    });
    setDragging(null);
  }, [dragging]);

  return (
    <div className="w-full h-full relative bg-gradient-to-br from-green-50 to-emerald-50 select-none"
         ref={containerRef}
         style={{touchAction:'none'}}
         onPointerMove={handlePointerMove}
         onPointerUp={handlePointerUp}
         onPointerCancel={handlePointerUp}>

      <div className="absolute top-3 inset-x-0 text-center">
        <p className="text-xs text-gray-500">ë™ë¬¼ì„ ë“œë˜ê·¸í•´ì„œ ì•Œë§ì€ ì§‘ì— ë†“ì•„ì£¼ì„¸ìš”!</p>
      </div>

      {/* Drop zones */}
      {ZONES.map(z => (
        <div key={z.id}
             className="absolute w-16 h-16 rounded-2xl border-2 border-dashed border-gray-300 flex flex-col items-center justify-center bg-white/60 backdrop-blur-sm transition-colors"
             style={{left:`${z.x}%`, top:`${z.y}%`, transform:'translate(-50%,-50%)'}}>
          <span className="text-2xl">{z.emoji}</span>
          <span className="text-[10px] text-gray-400 mt-0.5">{z.name}</span>
        </div>
      ))}

      {/* Draggable items */}
      {items.map(it => (
        <div key={it.id}
             className={`absolute flex flex-col items-center justify-center w-14 h-14 rounded-xl shadow-lg cursor-grab transition-shadow
               ${it.placed ? 'bg-green-100 border-2 border-green-400' : 'bg-white border border-gray-200'}
               ${dragging === it.id ? 'shadow-2xl z-30 scale-110' : 'z-20'}`}
             style={{
               left:`${it.x}%`, top:`${it.y}%`, transform:'translate(-50%,-50%)',
               transition: dragging === it.id ? 'none' : 'all 0.3s ease',
               touchAction:'none',
             }}
             onPointerDown={e => handlePointerDown(e, it.id)}>
          <span className="text-2xl">{it.emoji}</span>
          <span className="text-[10px] text-gray-500">{it.name}</span>
          {it.placed && <span className="absolute -top-1 -right-1 text-sm">âœ…</span>}
        </div>
      ))}

      {showOverlay && <CompletionOverlay stars={3} onNext={onComplete} />}
    </div>
  );
}

/* --- Coloring Activity --- */
function ColoringActivity({ onComplete }) {
  const PALETTE = ['#EF4444','#F97316','#EAB308','#22C55E','#3B82F6','#8B5CF6','#EC4899','#FFFFFF'];
  const canvasRef = useRef(null);
  const ctxRef = useRef(null);
  const [color, setColor] = useState(PALETTE[0]);
  const [tool, setTool] = useState('pen');
  const [lineWidth, setLineWidth] = useState(6);
  const drawing = useRef(false);
  const history = useRef([]);
  const [canUndo, setCanUndo] = useState(false);
  const [showOverlay, setShowOverlay] = useState(false);
  const containerRef = useRef(null);

  const setupCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return;
    const dpr = window.devicePixelRatio || 1;
    const w = container.clientWidth;
    const h = container.clientHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctxRef.current = ctx;
    drawButterfly(ctx, w, h);
    saveHistory();
  }, []);

  useEffect(() => { setupCanvas(); }, [setupCanvas]);

  const drawButterfly = (ctx, w, h) => {
    ctx.fillStyle = '#FEFCE8';
    ctx.fillRect(0, 0, w, h);
    const cx = w / 2, cy = h / 2 - 10;
    ctx.strokeStyle = '#374151';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(cx, cy - 50); ctx.lineTo(cx, cy + 70);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(cx - 55, cy - 15, 50, 65, -0.2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(cx + 55, cy - 15, 50, 65, 0.2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(cx - 35, cy + 45, 30, 40, -0.3, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(cx + 35, cy + 45, 30, 40, 0.3, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx - 15, cy - 50);
    ctx.quadraticCurveTo(cx - 40, cy - 90, cx - 30, cy - 100);
    ctx.moveTo(cx + 15, cy - 50);
    ctx.quadraticCurveTo(cx + 40, cy - 90, cx + 30, cy - 100);
    ctx.stroke();
    ctx.fillStyle = '#374151';
    ctx.beginPath(); ctx.arc(cx - 30, cy - 100, 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 30, cy - 100, 4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#374151';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('ğŸ¦‹ ë‚˜ë¹„ë¥¼ ì˜ˆì˜ê²Œ ìƒ‰ì¹ í•´ë³´ì„¸ìš”!', cx, 30);
  };

  const saveHistory = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    history.current.push(canvas.toDataURL());
    if (history.current.length > 30) history.current.shift();
    setCanUndo(history.current.length > 1);
  };

  const undo = () => {
    if (history.current.length <= 1) return;
    history.current.pop();
    const prev = history.current[history.current.length - 1];
    const img = new Image();
    img.onload = () => {
      const canvas = canvasRef.current;
      const ctx = ctxRef.current;
      const dpr = window.devicePixelRatio || 1;
      ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
      ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
    };
    img.src = prev;
    setCanUndo(history.current.length > 1);
  };

  const getPos = (e) => {
    const canvas = canvasRef.current;
    const r = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - r.left, y: clientY - r.top };
  };

  const handleStart = (e) => {
    e.preventDefault();
    const pos = getPos(e);
    if (tool === 'fill') {
      floodFill(canvasRef.current, ctxRef.current, pos.x, pos.y, color);
      saveHistory();
      return;
    }
    drawing.current = true;
    const ctx = ctxRef.current;
    ctx.strokeStyle = tool === 'eraser' ? '#FEFCE8' : color;
    ctx.lineWidth = tool === 'eraser' ? lineWidth * 3 : lineWidth;
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
  };

  const handleMove = (e) => {
    if (!drawing.current) return;
    e.preventDefault();
    const pos = getPos(e);
    const ctx = ctxRef.current;
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
  };

  const handleEnd = () => {
    if (drawing.current) {
      drawing.current = false;
      saveHistory();
    }
  };

  return (
    <div className="w-full h-full flex flex-col bg-amber-50 select-none">
      {/* Canvas area */}
      <div ref={containerRef} className="flex-1 relative overflow-hidden">
        <canvas ref={canvasRef}
                className="absolute inset-0"
                style={{touchAction:'none'}}
                onPointerDown={handleStart}
                onPointerMove={handleMove}
                onPointerUp={handleEnd}
                onPointerCancel={handleEnd} />
      </div>

      {/* Toolbar */}
      <div className="bg-white border-t border-gray-200 px-3 py-2">
        <div className="flex items-center gap-2 mb-2">
          {PALETTE.map(c => (
            <button key={c} onClick={() => { setColor(c); setTool('pen'); }}
                    className={`w-8 h-8 rounded-full border-2 transition-transform ${color === c && tool === 'pen' ? 'scale-125 border-gray-800' : 'border-gray-200'}`}
                    style={{backgroundColor: c, boxShadow: c === '#FFFFFF' ? 'inset 0 0 0 1px #ddd' : 'none'}} />
          ))}
        </div>
        <div className="flex items-center gap-2">
          <button onClick={() => setTool('pen')}
                  className={`px-3 py-1.5 rounded-lg text-xs font-semibold transition ${tool === 'pen' ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-600'}`}>
            âœï¸ íœ
          </button>
          <button onClick={() => setTool('fill')}
                  className={`px-3 py-1.5 rounded-lg text-xs font-semibold transition ${tool === 'fill' ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-600'}`}>
            ğŸª£ ì±„ìš°ê¸°
          </button>
          <button onClick={() => setTool('eraser')}
                  className={`px-3 py-1.5 rounded-lg text-xs font-semibold transition ${tool === 'eraser' ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-600'}`}>
            ğŸ§¹ ì§€ìš°ê°œ
          </button>
          <input type="range" min="2" max="20" value={lineWidth} onChange={e => setLineWidth(+e.target.value)}
                 className="flex-1 h-1.5 accent-gray-700" />
          <button onClick={undo} disabled={!canUndo}
                  className={`px-3 py-1.5 rounded-lg text-xs font-semibold ${canUndo ? 'bg-gray-100 text-gray-600' : 'bg-gray-50 text-gray-300'}`}>
            â†© ë˜ëŒë¦¬ê¸°
          </button>
          <button onClick={() => setShowOverlay(true)}
                  className="px-3 py-1.5 rounded-lg text-xs font-semibold bg-green-500 text-white">
            âœ… ì™„ë£Œ
          </button>
        </div>
      </div>

      {showOverlay && <CompletionOverlay stars={2} onNext={onComplete} />}
    </div>
  );
}

/* --- Line Match Activity --- */
function LineMatchActivity({ onComplete }) {
  const WORDS = [
    { id:'apple', text:'ì‚¬ê³¼', emoji:'ğŸ' },
    { id:'banana', text:'ë°”ë‚˜ë‚˜', emoji:'ğŸŒ' },
    { id:'grape', text:'í¬ë„', emoji:'ğŸ‡' },
    { id:'watermelon', text:'ìˆ˜ë°•', emoji:'ğŸ‰' },
  ];

  const containerRef = useRef(null);
  const [connections, setConnections] = useState([]);
  const [activeLine, setActiveLine] = useState(null);
  const [mousePos, setMousePos] = useState({x:0,y:0});
  const [wrongLine, setWrongLine] = useState(null);
  const [showOverlay, setShowOverlay] = useState(false);
  const leftRefs = useRef({});
  const rightRefs = useRef({});

  const shuffledRight = useMemo(() => [...WORDS].sort(() => Math.random() - 0.5), []);

  const getCenter = (el) => {
    if (!el || !containerRef.current) return {x:0,y:0};
    const cr = containerRef.current.getBoundingClientRect();
    const er = el.getBoundingClientRect();
    return { x: er.left + er.width/2 - cr.left, y: er.top + er.height/2 - cr.top };
  };

  const getSVGPos = (e) => {
    if (!containerRef.current) return {x:0,y:0};
    const cr = containerRef.current.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - cr.left, y: clientY - cr.top };
  };

  const handleLeftDown = (e, wordId) => {
    e.preventDefault();
    if (connections.find(c => c.from === wordId)) return;
    const pos = getSVGPos(e);
    const center = getCenter(leftRefs.current[wordId]);
    setActiveLine({ from: wordId, startX: center.x, startY: center.y });
    setMousePos(pos);
  };

  const handleMove = (e) => {
    if (!activeLine) return;
    e.preventDefault();
    setMousePos(getSVGPos(e));
  };

  const handleUp = (e) => {
    if (!activeLine) return;
    const pos = getSVGPos(e);
    let matched = null;
    shuffledRight.forEach(w => {
      const el = rightRefs.current[w.id];
      if (!el) return;
      const center = getCenter(el);
      const dist = Math.sqrt(Math.pow(pos.x - center.x, 2) + Math.pow(pos.y - center.y, 2));
      if (dist < 40 && !connections.find(c => c.to === w.id)) {
        matched = w;
      }
    });

    if (matched) {
      if (matched.id === activeLine.from) {
        const endCenter = getCenter(rightRefs.current[matched.id]);
        const newConn = { from: activeLine.from, to: matched.id, startX: activeLine.startX, startY: activeLine.startY, endX: endCenter.x, endY: endCenter.y, correct: true };
        const newConns = [...connections, newConn];
        setConnections(newConns);
        if (newConns.length === WORDS.length) {
          setTimeout(() => setShowOverlay(true), 600);
        }
      } else {
        const endCenter = getCenter(rightRefs.current[matched.id]);
        setWrongLine({ startX: activeLine.startX, startY: activeLine.startY, endX: endCenter.x, endY: endCenter.y });
        setTimeout(() => setWrongLine(null), 700);
      }
    }
    setActiveLine(null);
  };

  return (
    <div className="w-full h-full relative bg-gradient-to-br from-purple-50 to-pink-50 select-none overflow-hidden"
         ref={containerRef}
         style={{touchAction:'none'}}
         onPointerMove={handleMove}
         onPointerUp={handleUp}
         onPointerCancel={() => setActiveLine(null)}>

      <div className="absolute top-3 inset-x-0 text-center">
        <p className="text-xs text-gray-500">ì™¼ìª½ ë‹¨ì–´ë¥¼ ì˜¤ë¥¸ìª½ ê³¼ì¼ë¡œ ì„ ì„ ê·¸ì–´ ì—°ê²°í•˜ì„¸ìš”!</p>
      </div>

      {/* SVG overlay for lines */}
      <svg className="absolute inset-0 w-full h-full pointer-events-none z-10">
        {connections.map((c, i) => (
          <g key={i}>
            <line x1={c.startX} y1={c.startY} x2={c.endX} y2={c.endY}
                  stroke="#22C55E" strokeWidth="3" strokeLinecap="round" />
            <text x={(c.startX+c.endX)/2} y={(c.startY+c.endY)/2 - 8} textAnchor="middle" fontSize="16">âœ…</text>
          </g>
        ))}
        {activeLine && (
          <line x1={activeLine.startX} y1={activeLine.startY} x2={mousePos.x} y2={mousePos.y}
                stroke="#3B82F6" strokeWidth="3" strokeDasharray="8,4" strokeLinecap="round" opacity="0.7" />
        )}
        {wrongLine && (
          <line x1={wrongLine.startX} y1={wrongLine.startY} x2={wrongLine.endX} y2={wrongLine.endY}
                stroke="#EF4444" strokeWidth="3" strokeLinecap="round" opacity="0.8">
            <animate attributeName="opacity" from="0.8" to="0" dur="0.7s" fill="freeze" />
          </line>
        )}
      </svg>

      {/* Left column: words */}
      <div className="absolute left-6 top-1/2 -translate-y-1/2 flex flex-col gap-5 z-20">
        {WORDS.map(w => {
          const connected = connections.find(c => c.from === w.id);
          return (
            <div key={w.id}
                 ref={el => leftRefs.current[w.id] = el}
                 className={`px-5 py-3 rounded-xl font-bold text-sm shadow cursor-pointer transition-all
                   ${connected ? 'bg-green-100 text-green-700 border-2 border-green-400' : 'bg-white text-gray-700 border border-gray-200 active:scale-95'}`}
                 onPointerDown={e => handleLeftDown(e, w.id)}>
              {w.text}
            </div>
          );
        })}
      </div>

      {/* Right column: emojis */}
      <div className="absolute right-6 top-1/2 -translate-y-1/2 flex flex-col gap-5 z-20">
        {shuffledRight.map(w => {
          const connected = connections.find(c => c.to === w.id);
          return (
            <div key={w.id}
                 ref={el => rightRefs.current[w.id] = el}
                 className={`w-14 h-14 rounded-xl flex items-center justify-center text-3xl shadow transition-all
                   ${connected ? 'bg-green-100 border-2 border-green-400' : 'bg-white border border-gray-200'}`}>
              {w.emoji}
            </div>
          );
        })}
      </div>

      {showOverlay && <CompletionOverlay stars={3} onNext={onComplete} />}
    </div>
  );
}

/* --- Camera Module --- */
function CameraModule({ onComplete }) {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const [phase, setPhase] = useState('init'); // init | live | review | done
  const [photoSrc, setPhotoSrc] = useState(null);
  const streamRef = useRef(null);
  const [showOverlay, setShowOverlay] = useState(false);

  const SAMPLE_PHOTOS = ['ğŸ“š','ğŸŒˆ','ğŸŒ»','ğŸ¨'];

  const startCamera = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: {ideal: 'environment'}, width: {ideal:640}, height: {ideal:480} },
        audio: false,
      });
      streamRef.current = stream;
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        videoRef.current.play();
      }
      setPhase('live');
    } catch(err) {
      console.warn('Camera not available:', err);
      setPhase('fallback');
    }
  }, []);

  const stopCamera = useCallback(() => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(t => t.stop());
      streamRef.current = null;
    }
  }, []);

  useEffect(() => {
    startCamera();
    return () => stopCamera();
  }, [startCamera, stopCamera]);

  const capture = () => {
    const video = videoRef.current;
    const canvas = canvasRef.current;
    if (!video || !canvas) return;
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    setPhotoSrc(canvas.toDataURL('image/jpeg', 0.85));
    stopCamera();
    setPhase('review');
  };

  const retake = () => {
    setPhotoSrc(null);
    startCamera();
  };

  const useSample = (emoji) => {
    const canvas = canvasRef.current || document.createElement('canvas');
    canvas.width = 400; canvas.height = 400;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#F0F9FF';
    ctx.fillRect(0, 0, 400, 400);
    ctx.font = '120px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, 200, 200);
    setPhotoSrc(canvas.toDataURL('image/png'));
    setPhase('review');
  };

  const confirmPhoto = () => {
    setPhase('done');
  };

  return (
    <div className="w-full h-full flex flex-col items-center justify-center bg-gradient-to-br from-slate-800 to-slate-900 select-none relative">
      <canvas ref={canvasRef} className="hidden" />

      {phase === 'init' && (
        <div className="flex flex-col items-center gap-3">
          <div className="w-8 h-8 border-2 border-white/30 border-t-white rounded-full animate-spin" />
          <span className="text-sm text-white/60">ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...</span>
        </div>
      )}

      {phase === 'live' && (
        <div className="flex flex-col items-center gap-4">
          <div className="relative rounded-2xl overflow-hidden shadow-2xl border-4 border-white/20">
            <video ref={videoRef} className="w-72 h-56 object-cover bg-black" autoPlay playsInline muted />
          </div>
          <button onClick={capture}
                  className="w-16 h-16 rounded-full bg-white flex items-center justify-center shadow-lg active:scale-95 transition-transform">
            <div className="w-12 h-12 rounded-full border-4 border-gray-300" />
          </button>
          <p className="text-xs text-white/50">ì…”í„° ë²„íŠ¼ì„ ëˆŒëŸ¬ ì´¬ì˜í•˜ì„¸ìš”</p>
        </div>
      )}

      {phase === 'fallback' && (
        <div className="flex flex-col items-center gap-4 px-8">
          <span className="text-4xl">ğŸ“·</span>
          <p className="text-sm text-white/70 text-center">ì¹´ë©”ë¼ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ì–´ìš”.<br/>ì•„ë˜ì—ì„œ ìƒ˜í”Œ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”!</p>
          <div className="flex gap-3 mt-2">
            {SAMPLE_PHOTOS.map(em => (
              <button key={em} onClick={() => useSample(em)}
                      className="w-16 h-16 rounded-xl bg-white/10 flex items-center justify-center text-3xl hover:bg-white/20 active:scale-95 transition-all border border-white/20">
                {em}
              </button>
            ))}
          </div>
        </div>
      )}

      {phase === 'review' && photoSrc && (
        <div className="flex flex-col items-center gap-4">
          <div className="bg-white p-3 pb-10 rounded shadow-2xl transform -rotate-2">
            <img src={photoSrc} className="w-64 h-48 object-cover rounded" alt="ì´¬ì˜ ì‚¬ì§„" />
            <p className="text-center text-xs text-gray-400 mt-2 font-semibold">ë¶í´ëŸ½ 3.0</p>
          </div>
          <div className="flex gap-3 mt-2">
            <button onClick={retake}
                    className="px-5 py-2.5 rounded-full bg-white/10 text-white text-sm font-semibold border border-white/20 active:scale-95 transition">
              ğŸ”„ ë‹¤ì‹œì°ê¸°
            </button>
            <button onClick={confirmPhoto}
                    className="px-5 py-2.5 rounded-full bg-white text-gray-800 text-sm font-bold active:scale-95 transition shadow-lg">
              âœ… ì‚¬ìš©í•˜ê¸°
            </button>
          </div>
        </div>
      )}

      {phase === 'done' && photoSrc && (
        <div className="flex flex-col items-center gap-4">
          <div className="relative">
            <div className="bg-white p-4 pb-14 rounded-lg shadow-2xl transform rotate-1">
              <img src={photoSrc} className="w-64 h-48 object-cover rounded" alt="ë‚´ ì‚¬ì§„" />
              <div className="absolute bottom-4 inset-x-0 text-center">
                <p className="text-sm font-bold text-gray-700">ë‚˜ì˜ ë¶í´ëŸ½ ì‚¬ì§„</p>
                <p className="text-[10px] text-gray-400 mt-0.5">{new Date().toLocaleDateString('ko-KR')}</p>
              </div>
            </div>
            <div className="absolute -top-3 -right-3 text-2xl animate-bounce">ğŸ“Œ</div>
          </div>
          {!showOverlay && (
            <button onClick={() => setShowOverlay(true)}
                    className="mt-4 px-8 py-3 bg-gradient-to-r from-blue-500 to-indigo-500 text-white font-bold rounded-full shadow-lg active:scale-95 transition-transform text-sm">
              ì™„ë£Œí•˜ê¸° ğŸ‰
            </button>
          )}
          {showOverlay && <CompletionOverlay stars={2} onNext={onComplete} />}
        </div>
      )}
    </div>
  );
}

/* --- Interactive Viewer (Orchestrator) --- */
function InteractiveViewer({ onExit }) {
  const [state, dispatch] = useReducer(activityReducer, {
    completed: new Set(),
    currentPage: 1,
    totalStars: 0,
  });

  const currentDef = DEMO_PAGES[state.currentPage - 1];
  const totalPages = DEMO_PAGES.length;
  const completedCount = state.completed.size;

  const goNext = useCallback(() => {
    if (state.currentPage < totalPages) {
      dispatch({ type: 'SET_PAGE', page: state.currentPage + 1 });
    }
  }, [state.currentPage, totalPages]);

  const goPrev = useCallback(() => {
    if (state.currentPage > 1) {
      dispatch({ type: 'SET_PAGE', page: state.currentPage - 1 });
    }
  }, [state.currentPage]);

  const handleActivityComplete = useCallback(() => {
    dispatch({ type: 'COMPLETE_PAGE', pageId: currentDef.id, stars: currentDef.stars });
    if (state.currentPage < totalPages) {
      dispatch({ type: 'SET_PAGE', page: state.currentPage + 1 });
    }
  }, [currentDef, state.currentPage, totalPages]);

  const renderActivity = () => {
    switch(currentDef.type) {
      case 'intro': return <IntroPage onComplete={handleActivityComplete} />;
      case 'drag':  return <DragDropActivity onComplete={handleActivityComplete} />;
      case 'color': return <ColoringActivity onComplete={handleActivityComplete} />;
      case 'match': return <LineMatchActivity onComplete={handleActivityComplete} />;
      case 'camera': return <CameraModule onComplete={handleActivityComplete} />;
      default: return null;
    }
  };

  return (
    <div className="w-full h-full flex flex-col bg-white">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-2 bg-white border-b border-gray-100 z-30 shrink-0">
        <button onClick={onExit}
                className="w-9 h-9 rounded-lg bg-gray-100 flex items-center justify-center text-base active:scale-95 transition-transform">â†</button>
        <span className="text-sm font-bold text-gray-700 truncate max-w-[180px]">{currentDef.title}</span>
        <div className="flex items-center gap-1.5">
          <span className="text-sm">â­</span>
          <span className="text-xs font-bold text-amber-500">{state.totalStars}</span>
        </div>
      </div>

      {/* Activity area */}
      <div className="flex-1 relative overflow-hidden">
        {renderActivity()}
      </div>

      {/* Bottom progress bar */}
      <div className="flex items-center gap-3 px-4 py-2 bg-white border-t border-gray-100 shrink-0">
        <button onClick={goPrev} disabled={state.currentPage <= 1}
                className={`px-3 py-1.5 rounded-lg text-xs font-semibold transition ${state.currentPage <= 1 ? 'text-gray-300' : 'text-gray-600 bg-gray-100 active:scale-95'}`}>
          â€¹ ì´ì „
        </button>
        <div className="flex-1 flex items-center gap-1.5">
          {DEMO_PAGES.map((p, i) => (
            <div key={p.id}
                 onClick={() => dispatch({ type: 'SET_PAGE', page: i + 1 })}
                 className={`flex-1 h-2 rounded-full cursor-pointer transition-all ${
                   state.completed.has(p.id) ? 'bg-green-400' :
                   state.currentPage === i + 1 ? 'bg-blue-400' : 'bg-gray-200'
                 }`} />
          ))}
        </div>
        <span className="text-[10px] text-gray-400 min-w-[40px] text-center">{completedCount}/{totalPages}</span>
        <button onClick={goNext} disabled={state.currentPage >= totalPages}
                className={`px-3 py-1.5 rounded-lg text-xs font-semibold transition ${state.currentPage >= totalPages ? 'text-gray-300' : 'text-gray-600 bg-gray-100 active:scale-95'}`}>
          ë‹¤ìŒ â€º
        </button>
      </div>
    </div>
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   REPORT SYSTEM â€” ê°ìƒë¬¸ ì €ì¥/ì“°ê¸°/ë³´ê¸°
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

const REPORTS_KEY = 'bookclub3_reports';
function loadReports() {
  try { return JSON.parse(localStorage.getItem(REPORTS_KEY) || '[]'); } catch(e) { return []; }
}
function persistReports(arr) { localStorage.setItem(REPORTS_KEY, JSON.stringify(arr)); }
function upsertReport(report) {
  const arr = loadReports();
  const idx = arr.findIndex(r => r.id === report.id);
  if (idx >= 0) arr[idx] = report; else arr.unshift(report);
  persistReports(arr);
}
function removeReport(id) { persistReports(loadReports().filter(r => r.id !== id)); }
function newId() { return Date.now().toString(36) + Math.random().toString(36).substr(2, 6); }

/* --- Camera Capture (lightweight, for report writer) --- */
function CameraCapture({ onCapture, onCancel }) {
  const videoRef = useRef(null);
  const streamRef = useRef(null);
  const [ready, setReady] = useState(false);

  useEffect(() => {
    let cancelled = false;
    navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' }, width: { ideal: 640 }, height: { ideal: 480 } }, audio: false,
    }).then(stream => {
      if (cancelled) { stream.getTracks().forEach(t => t.stop()); return; }
      streamRef.current = stream;
      if (videoRef.current) { videoRef.current.srcObject = stream; videoRef.current.play(); }
      setReady(true);
    }).catch(() => onCancel());
    return () => { cancelled = true; if (streamRef.current) streamRef.current.getTracks().forEach(t => t.stop()); };
  }, []);

  const capture = () => {
    const v = videoRef.current; if (!v) return;
    const c = document.createElement('canvas');
    c.width = v.videoWidth; c.height = v.videoHeight;
    c.getContext('2d').drawImage(v, 0, 0);
    if (streamRef.current) streamRef.current.getTracks().forEach(t => t.stop());
    onCapture(c.toDataURL('image/jpeg', 0.85));
  };

  return (
    <div className="fixed inset-0 z-[100] bg-black flex flex-col items-center justify-center gap-4" style={{touchAction:'none'}}>
      <video ref={videoRef} className="w-72 h-56 rounded-xl object-cover bg-gray-900" autoPlay playsInline muted />
      {ready ? (
        <div className="flex items-center gap-4">
          <button onClick={onCancel} className="px-5 py-2 rounded-lg bg-white/20 text-white text-sm font-semibold">ì·¨ì†Œ</button>
          <button onClick={capture} className="w-16 h-16 rounded-full bg-white flex items-center justify-center shadow-lg active:scale-95">
            <div className="w-12 h-12 rounded-full border-4 border-gray-300" />
          </button>
        </div>
      ) : (
        <div className="text-white/60 text-sm">ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...</div>
      )}
    </div>
  );
}

/* --- Crop Modal --- */
function CropModal({ src, onApply, onCancel }) {
  const imgRef = useRef(null);
  const [rect, setRect] = useState({ x: 10, y: 10, w: 80, h: 80 });
  const [drag, setDrag] = useState(null);

  useEffect(() => {
    if (!drag) return;
    const onMove = (e) => {
      const img = imgRef.current; if (!img) return;
      const ib = img.getBoundingClientRect();
      const dx = ((e.clientX - drag.sx) / ib.width) * 100;
      const dy = ((e.clientY - drag.sy) / ib.height) * 100;
      const r = drag.sr;
      let n = { ...r };
      if (drag.t === 'move') {
        n.x = Math.max(0, Math.min(100 - r.w, r.x + dx));
        n.y = Math.max(0, Math.min(100 - r.h, r.y + dy));
      } else if (drag.t === 'se') {
        n.w = Math.max(10, Math.min(100 - r.x, r.w + dx));
        n.h = Math.max(10, Math.min(100 - r.y, r.h + dy));
      } else if (drag.t === 'nw') {
        const nx = Math.max(0, Math.min(r.x + r.w - 10, r.x + dx));
        const ny = Math.max(0, Math.min(r.y + r.h - 10, r.y + dy));
        n = { x: nx, y: ny, w: r.w - (nx - r.x), h: r.h - (ny - r.y) };
      } else if (drag.t === 'ne') {
        const ny = Math.max(0, Math.min(r.y + r.h - 10, r.y + dy));
        n = { x: r.x, y: ny, w: Math.max(10, Math.min(100 - r.x, r.w + dx)), h: r.h - (ny - r.y) };
      } else if (drag.t === 'sw') {
        const nx = Math.max(0, Math.min(r.x + r.w - 10, r.x + dx));
        n = { x: nx, y: r.y, w: r.w - (nx - r.x), h: Math.max(10, Math.min(100 - r.y, r.h + dy)) };
      }
      setRect(n);
    };
    const onUp = () => setDrag(null);
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
    return () => { window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); };
  }, [drag]);

  const startDrag = (e, t) => {
    e.preventDefault(); e.stopPropagation();
    setDrag({ t, sx: e.clientX, sy: e.clientY, sr: { ...rect } });
  };

  const apply = () => {
    const img = imgRef.current; if (!img) return;
    const c = document.createElement('canvas');
    const sx = (rect.x / 100) * img.naturalWidth, sy = (rect.y / 100) * img.naturalHeight;
    const sw = (rect.w / 100) * img.naturalWidth, sh = (rect.h / 100) * img.naturalHeight;
    c.width = sw; c.height = sh;
    c.getContext('2d').drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
    onApply(c.toDataURL('image/jpeg', 0.85));
  };

  const hp = {
    nw: { left: `${rect.x}%`, top: `${rect.y}%` },
    ne: { left: `${rect.x + rect.w}%`, top: `${rect.y}%` },
    sw: { left: `${rect.x}%`, top: `${rect.y + rect.h}%` },
    se: { left: `${rect.x + rect.w}%`, top: `${rect.y + rect.h}%` },
  };

  return (
    <div className="fixed inset-0 z-[100] bg-black/90 flex flex-col items-center justify-center select-none" style={{touchAction:'none'}}>
      <p className="text-white text-sm font-semibold mb-3">ë“œë˜ê·¸í•˜ì—¬ ìë¥¼ ì˜ì—­ì„ ì¡°ì •í•˜ì„¸ìš”</p>
      <div className="relative inline-block max-w-[90vw] max-h-[65vh]">
        <img ref={imgRef} src={src} className="block max-w-[90vw] max-h-[65vh]" />
        <div className="absolute inset-0">
          <div className="absolute border-2 border-white/90 border-dashed cursor-move"
               style={{ left:`${rect.x}%`, top:`${rect.y}%`, width:`${rect.w}%`, height:`${rect.h}%`,
                        boxShadow:'0 0 0 9999px rgba(0,0,0,0.55)' }}
               onPointerDown={e => startDrag(e, 'move')} />
          {['nw','ne','sw','se'].map(h => (
            <div key={h}
                 className="absolute w-5 h-5 bg-white rounded-full border-2 border-blue-500 -translate-x-1/2 -translate-y-1/2 cursor-pointer z-10"
                 style={hp[h]}
                 onPointerDown={e => startDrag(e, h)} />
          ))}
        </div>
      </div>
      <div className="flex gap-3 mt-4">
        <button onClick={onCancel} className="px-5 py-2.5 rounded-lg bg-white/10 text-white text-sm font-semibold">ì·¨ì†Œ</button>
        <button onClick={apply} className="px-5 py-2.5 rounded-lg bg-blue-500 text-white text-sm font-bold">ìë¥´ê¸° ì ìš©</button>
      </div>
    </div>
  );
}


/* --- Report Writer (í™œë™ íˆ´) --- */
function ReportWriter({ bookName, pageImageSrc, onExit, existingReport }) {
  const reportId = useRef(existingReport?.id || newId()).current;
  const [tab, setTab] = useState('write');
  const [title, setTitle] = useState(existingReport?.title || '');
  const [bodyText, setBodyText] = useState(existingReport?.bodyText || '');
  const [photos, setPhotos] = useState(existingReport?.photos || []);
  const [selectedPhotoId, setSelectedPhotoId] = useState(null);
  const [tool, setTool] = useState('pen');
  const [penColor, setPenColor] = useState('#000000');
  const [penSize, setPenSize] = useState(4);
  const canvasRef = useRef(null);
  const ctxRef = useRef(null);
  const workspaceRef = useRef(null);
  const isDrawing = useRef(false);
  const historyStack = useRef([]);
  const [canUndo, setCanUndo] = useState(false);
  const [saved, setSaved] = useState(false);
  const [showCamera, setShowCamera] = useState(false);
  const [showCrop, setShowCrop] = useState(null);
  const photoFileRef = useRef(null);
  const [photoDrag, setPhotoDrag] = useState(null);
  const existingDrawingLoaded = useRef(false);

  const COLORS = ['#000000','#EF4444','#F97316','#EAB308','#22C55E','#3B82F6','#8B5CF6','#EC4899','#FFFFFF'];

  /* Canvas setup */
  const initCanvas = useCallback(() => {
    const c = canvasRef.current, ws = workspaceRef.current;
    if (!c || !ws) return;
    const dpr = window.devicePixelRatio || 1;
    const w = ws.clientWidth, h = ws.clientHeight;
    c.width = w * dpr; c.height = h * dpr;
    c.style.width = w + 'px'; c.style.height = h + 'px';
    const ctx = c.getContext('2d');
    ctx.scale(dpr, dpr);
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctxRef.current = ctx;
    if (existingReport?.drawingData && !existingDrawingLoaded.current) {
      existingDrawingLoaded.current = true;
      const img = new Image();
      img.onload = () => { ctx.drawImage(img, 0, 0, w, h); pushHist(); };
      img.src = existingReport.drawingData;
    } else {
      pushHist();
    }
  }, []);

  useEffect(() => {
    if (tab === 'decorate') setTimeout(initCanvas, 80);
  }, [tab, initCanvas]);

  const pushHist = () => {
    if (!canvasRef.current) return;
    historyStack.current.push(canvasRef.current.toDataURL());
    if (historyStack.current.length > 30) historyStack.current.shift();
    setCanUndo(historyStack.current.length > 1);
  };

  const undo = () => {
    if (historyStack.current.length <= 1) return;
    historyStack.current.pop();
    const last = historyStack.current[historyStack.current.length - 1];
    const img = new Image();
    img.onload = () => {
      const dpr = window.devicePixelRatio || 1;
      ctxRef.current.clearRect(0, 0, canvasRef.current.width / dpr, canvasRef.current.height / dpr);
      ctxRef.current.drawImage(img, 0, 0, canvasRef.current.width / dpr, canvasRef.current.height / dpr);
    };
    img.src = last;
    setCanUndo(historyStack.current.length > 1);
  };

  /* Drawing handlers */
  const cPos = (e) => {
    const r = canvasRef.current.getBoundingClientRect();
    return { x: (e.clientX || (e.touches && e.touches[0].clientX) || 0) - r.left,
             y: (e.clientY || (e.touches && e.touches[0].clientY) || 0) - r.top };
  };

  const onCanvasDown = (e) => {
    if (tool === 'photo') { setSelectedPhotoId(null); return; }
    e.preventDefault();
    const p = cPos(e);
    if (tool === 'fill') { floodFill(canvasRef.current, ctxRef.current, p.x, p.y, penColor); pushHist(); return; }
    isDrawing.current = true;
    const ctx = ctxRef.current;
    ctx.strokeStyle = tool === 'eraser' ? '#FFFFFF' : penColor;
    ctx.lineWidth = tool === 'eraser' ? penSize * 3 : penSize;
    ctx.beginPath(); ctx.moveTo(p.x, p.y);
  };
  const onCanvasMove = (e) => {
    if (!isDrawing.current) return; e.preventDefault();
    const p = cPos(e);
    ctxRef.current.lineTo(p.x, p.y); ctxRef.current.stroke();
  };
  const onCanvasUp = () => { if (isDrawing.current) { isDrawing.current = false; pushHist(); } };

  /* Photo import */
  const importPhoto = (e) => {
    const file = e.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = () => {
        let w = img.width, h = img.height;
        const max = 800;
        if (w > max || h > max) { if (w > h) { h = (h/w)*max; w = max; } else { w = (w/h)*max; h = max; } }
        const c2 = document.createElement('canvas'); c2.width = w; c2.height = h;
        c2.getContext('2d').drawImage(img, 0, 0, w, h);
        const np = { id: newId(), src: c2.toDataURL('image/jpeg', 0.8), x: 10, y: 10, w: 40, h: 40*(h/w) };
        setPhotos(prev => [...prev, np]); setSelectedPhotoId(np.id); setTool('photo');
      };
      img.src = reader.result;
    };
    reader.readAsDataURL(file); e.target.value = '';
  };

  const addCameraPhoto = (dataUrl) => {
    const np = { id: newId(), src: dataUrl, x: 10, y: 10, w: 40, h: 30 };
    setPhotos(prev => [...prev, np]); setSelectedPhotoId(np.id); setTool('photo'); setShowCamera(false);
  };

  /* Photo drag / resize */
  useEffect(() => {
    if (!photoDrag) return;
    const onMove = (e) => {
      const dx = ((e.clientX - photoDrag.sx) / photoDrag.ww) * 100;
      const dy = ((e.clientY - photoDrag.sy) / photoDrag.wh) * 100;
      const sp = photoDrag.sp;
      setPhotos(prev => prev.map(p => {
        if (p.id !== photoDrag.pid) return p;
        if (photoDrag.action === 'move') return { ...p, x: sp.x + dx, y: sp.y + dy };
        if (photoDrag.action === 'resize') { const nw = Math.max(10, sp.w + dx); return { ...p, w: nw, h: nw * (sp.h / sp.w) }; }
        return p;
      }));
    };
    const onUp = () => setPhotoDrag(null);
    window.addEventListener('pointermove', onMove); window.addEventListener('pointerup', onUp);
    return () => { window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); };
  }, [photoDrag]);

  const startPhotoDrag = (e, photoId, action) => {
    e.preventDefault(); e.stopPropagation();
    setSelectedPhotoId(photoId);
    const ws = workspaceRef.current; if (!ws) return;
    const wr = ws.getBoundingClientRect();
    setPhotoDrag({ action, pid: photoId, sx: e.clientX, sy: e.clientY, ww: wr.width, wh: wr.height, sp: { ...photos.find(p => p.id === photoId) } });
  };

  const deletePhoto = (pid) => { setPhotos(prev => prev.filter(p => p.id !== pid)); if (selectedPhotoId === pid) setSelectedPhotoId(null); };
  const handleCrop = (croppedSrc) => { setPhotos(prev => prev.map(p => p.id === showCrop ? { ...p, src: croppedSrc } : p)); setShowCrop(null); };

  const addPageImage = () => {
    if (!pageImageSrc) return;
    const np = { id: newId(), src: pageImageSrc, x: 5, y: 5, w: 50, h: 38 };
    setPhotos(prev => [...prev, np]); setSelectedPhotoId(np.id); setTool('photo'); setTab('decorate');
  };

  /* Save */
  const handleSave = () => {
    const drawingData = canvasRef.current ? canvasRef.current.toDataURL('image/jpeg', 0.5) : null;
    const thumbnail = canvasRef.current ? canvasRef.current.toDataURL('image/jpeg', 0.15) : null;
    upsertReport({
      id: reportId, bookName, title, bodyText, photos, drawingData, thumbnail,
      createdAt: existingReport?.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    });
    setSaved(true); setTimeout(() => setSaved(false), 2000);
  };

  return (
    <div className="w-full h-full flex flex-col bg-white">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-2 bg-white border-b border-gray-100 shrink-0">
        <button onClick={onExit} className="w-9 h-9 rounded-lg bg-gray-100 flex items-center justify-center text-base active:scale-95">â†</button>
        <span className="text-sm font-bold text-gray-700">ê°ìƒë¬¸ ì“°ê¸°</span>
        <button onClick={handleSave}
                className={`px-4 py-1.5 rounded-lg text-sm font-bold transition ${saved ? 'bg-green-500 text-white' : 'bg-blue-500 text-white active:scale-95'}`}>
          {saved ? 'âœ“ ì €ì¥ë¨' : 'ğŸ’¾ ì €ì¥'}
        </button>
      </div>

      {/* Tabs */}
      <div className="flex border-b border-gray-100 shrink-0">
        <button onClick={() => setTab('write')}
                className={`flex-1 py-2.5 text-sm font-semibold transition ${tab==='write' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-gray-400'}`}>
          âœï¸ ê¸€ì“°ê¸°
        </button>
        <button onClick={() => setTab('decorate')}
                className={`flex-1 py-2.5 text-sm font-semibold transition ${tab==='decorate' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-gray-400'}`}>
          ğŸ¨ ê¾¸ë¯¸ê¸°
        </button>
      </div>

      {/* Write tab */}
      {tab === 'write' && (
        <div className="flex-1 overflow-auto p-4">
          <div className="flex items-center gap-2 mb-3">
            <span className="text-xs text-gray-400 shrink-0">ğŸ“– {bookName}</span>
            {pageImageSrc && (
              <button onClick={addPageImage} className="text-[10px] text-blue-500 underline shrink-0">í˜ì´ì§€ ì´ë¯¸ì§€ë¥¼ ê¾¸ë¯¸ê¸°ì— ì¶”ê°€</button>
            )}
          </div>
          <input value={title} onChange={e => setTitle(e.target.value)}
                 placeholder="ê°ìƒë¬¸ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                 className="w-full px-3 py-2.5 rounded-lg border border-gray-200 text-sm font-semibold mb-3 focus:outline-none focus:border-blue-400" />
          <textarea value={bodyText} onChange={e => setBodyText(e.target.value)}
                    placeholder="ì±…ì„ ì½ê³  ëŠë‚€ ì ì„ ììœ ë¡­ê²Œ ì¨ë³´ì„¸ìš”..."
                    className="w-full min-h-[300px] px-3 py-2.5 rounded-lg border border-gray-200 text-sm leading-relaxed resize-none focus:outline-none focus:border-blue-400"
                    style={{ height: 'calc(100% - 90px)' }} />
        </div>
      )}

      {/* Decorate tab */}
      {tab === 'decorate' && (
        <>
          <div ref={workspaceRef} className="flex-1 relative overflow-hidden bg-white" style={{touchAction:'none'}}>
            {/* Photos layer */}
            {photos.map(p => (
              <div key={p.id}
                   className={`absolute ${tool==='photo' ? 'cursor-move' : 'pointer-events-none'}`}
                   style={{ left:`${p.x}%`, top:`${p.y}%`, width:`${p.w}%`, height:`${p.h}%` }}>
                <img src={p.src} className="w-full h-full object-cover rounded shadow" draggable={false}
                     onPointerDown={e => tool==='photo' && startPhotoDrag(e, p.id, 'move')} />
                {selectedPhotoId === p.id && tool === 'photo' && (
                  <>
                    <div className="absolute inset-0 border-2 border-blue-500 rounded pointer-events-none" />
                    <div className="absolute -bottom-2.5 -right-2.5 w-6 h-6 bg-blue-500 rounded-full cursor-se-resize z-10 flex items-center justify-center"
                         onPointerDown={e => startPhotoDrag(e, p.id, 'resize')}>
                      <span className="text-white text-[10px]">â†˜</span>
                    </div>
                    <button className="absolute -top-3 left-1/2 -translate-x-1/2 px-2 py-0.5 bg-blue-500 text-white text-[10px] rounded-full font-bold z-10 whitespace-nowrap"
                            onClick={e => { e.stopPropagation(); setShowCrop(p.id); }}>
                      âœ‚ï¸ ìë¥´ê¸°
                    </button>
                    <button className="absolute -top-2 -right-2 w-5 h-5 bg-red-500 text-white text-[10px] rounded-full flex items-center justify-center font-bold z-10"
                            onClick={e => { e.stopPropagation(); deletePhoto(p.id); }}>
                      Ã—
                    </button>
                  </>
                )}
              </div>
            ))}
            {/* Drawing canvas */}
            <canvas ref={canvasRef} className="absolute inset-0"
                    style={{ touchAction:'none', pointerEvents: tool==='photo' ? 'none' : 'auto' }}
                    onPointerDown={onCanvasDown} onPointerMove={onCanvasMove}
                    onPointerUp={onCanvasUp} onPointerCancel={onCanvasUp} />
          </div>

          {/* Toolbar */}
          <div className="bg-white border-t border-gray-200 px-3 py-2 shrink-0">
            <div className="flex items-center gap-1.5 mb-2">
              {COLORS.map(c => (
                <button key={c} onClick={() => { setPenColor(c); if(tool==='photo') setTool('pen'); }}
                        className={`w-7 h-7 rounded-full border-2 transition-transform ${penColor===c && tool!=='photo' ? 'scale-125 border-gray-800' : 'border-gray-200'}`}
                        style={{ backgroundColor:c, boxShadow: c==='#FFFFFF' ? 'inset 0 0 0 1px #ddd' : 'none' }} />
              ))}
              <input type="range" min="2" max="20" value={penSize} onChange={e => setPenSize(+e.target.value)}
                     className="flex-1 h-1 accent-gray-700 ml-2" />
            </div>
            <div className="flex items-center gap-1.5 flex-wrap">
              {[
                { id:'pen', icon:'âœï¸', label:'íœ' },
                { id:'fill', icon:'ğŸª£', label:'ì±„ìš°ê¸°' },
                { id:'eraser', icon:'ğŸ§¹', label:'ì§€ìš°ê°œ' },
                { id:'photo', icon:'ğŸ–¼ï¸', label:'ì‚¬ì§„ì„ íƒ' },
              ].map(t => (
                <button key={t.id} onClick={() => setTool(t.id)}
                        className={`px-2.5 py-1.5 rounded-lg text-[11px] font-semibold transition ${tool===t.id ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-600'}`}>
                  {t.icon} {t.label}
                </button>
              ))}
              <button onClick={() => photoFileRef.current?.click()}
                      className="px-2.5 py-1.5 rounded-lg text-[11px] font-semibold bg-gray-100 text-gray-600">ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°</button>
              <button onClick={() => setShowCamera(true)}
                      className="px-2.5 py-1.5 rounded-lg text-[11px] font-semibold bg-gray-100 text-gray-600">ğŸ“· ì¹´ë©”ë¼</button>
              <button onClick={undo} disabled={!canUndo}
                      className={`px-2.5 py-1.5 rounded-lg text-[11px] font-semibold ${canUndo ? 'bg-gray-100 text-gray-600' : 'bg-gray-50 text-gray-300'}`}>
                â†© ë˜ëŒë¦¬ê¸°
              </button>
            </div>
          </div>
          <input ref={photoFileRef} type="file" accept="image/*" hidden onChange={importPhoto} />
        </>
      )}

      {showCamera && <CameraCapture onCapture={addCameraPhoto} onCancel={() => setShowCamera(false)} />}
      {showCrop && (() => { const ph = photos.find(p => p.id === showCrop); return ph ? <CropModal src={ph.src} onApply={handleCrop} onCancel={() => setShowCrop(null)} /> : null; })()}
    </div>
  );
}

/* --- Report Gallery (ê°ìƒë¬¸ ë³´ê¸°) --- */
function ReportGallery({ bookName, onExit, onEdit }) {
  const [reports, setReports] = useState(() => loadReports());
  const [confirmDel, setConfirmDel] = useState(null);
  const [viewReport, setViewReport] = useState(null);
  const thisBook = bookName ? reports.filter(r => r.bookName === bookName) : [];
  const otherBooks = bookName ? reports.filter(r => r.bookName !== bookName) : reports;

  const handleDelete = (id) => { removeReport(id); setReports(loadReports()); setConfirmDel(null); };

  const Card = ({ report }) => (
    <div className="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden">
      <div className="h-28 bg-gray-100 flex items-center justify-center overflow-hidden cursor-pointer"
           onClick={() => setViewReport(report)}>
        {report.thumbnail ? <img src={report.thumbnail} className="w-full h-full object-cover" /> : <span className="text-4xl">ğŸ“</span>}
      </div>
      <div className="p-2.5">
        <h4 className="text-xs font-bold text-gray-700 truncate">{report.title || 'ì œëª© ì—†ìŒ'}</h4>
        <p className="text-[10px] text-gray-400 mt-0.5">ğŸ“– {report.bookName}</p>
        <p className="text-[10px] text-gray-400">{new Date(report.updatedAt).toLocaleDateString('ko-KR')}</p>
        {report.bodyText && <p className="text-[10px] text-gray-500 mt-1 line-clamp-2">{report.bodyText}</p>}
        <div className="flex gap-1.5 mt-2">
          <button onClick={() => onEdit(report)} className="flex-1 py-1.5 rounded-lg bg-blue-50 text-blue-600 text-[10px] font-semibold active:scale-95">ìˆ˜ì •</button>
          <button onClick={() => setConfirmDel(report.id)} className="py-1.5 px-2 rounded-lg bg-red-50 text-red-500 text-[10px] font-semibold active:scale-95">ğŸ—‘</button>
        </div>
      </div>
    </div>
  );

  return (
    <div className="w-full h-full flex flex-col bg-gray-50 relative">
      <div className="flex items-center justify-between px-4 py-3 bg-white border-b border-gray-100 shrink-0">
        <button onClick={onExit} className="w-9 h-9 rounded-lg bg-gray-100 flex items-center justify-center text-base active:scale-95">â†</button>
        <span className="text-sm font-bold text-gray-700">ë‚´ ê°ìƒë¬¸ ëª¨ì•„ë³´ê¸°</span>
        <span className="text-xs text-gray-400">{reports.length}í¸</span>
      </div>
      <div className="flex-1 overflow-auto p-4">
        {reports.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-full gap-3">
            <span className="text-5xl">ğŸ“’</span>
            <p className="text-sm text-gray-400">ì•„ì§ ì‘ì„±í•œ ê°ìƒë¬¸ì´ ì—†ì–´ìš”</p>
          </div>
        ) : (
          <>
            {thisBook.length > 0 && (
              <div className="mb-4">
                <h3 className="text-xs font-bold text-gray-500 mb-2">ğŸ“– {bookName}</h3>
                <div className="grid grid-cols-2 gap-3">{thisBook.map(r => <Card key={r.id} report={r} />)}</div>
              </div>
            )}
            {otherBooks.length > 0 && (
              <div>
                <h3 className="text-xs font-bold text-gray-500 mb-2">{bookName ? 'ë‹¤ë¥¸ ë„ì„œ' : 'ì „ì²´ ê°ìƒë¬¸'}</h3>
                <div className="grid grid-cols-2 gap-3">{otherBooks.map(r => <Card key={r.id} report={r} />)}</div>
              </div>
            )}
          </>
        )}
      </div>

      {/* View detail modal */}
      {viewReport && (
        <div className="absolute inset-0 z-40 bg-white flex flex-col">
          <div className="flex items-center justify-between px-4 py-3 border-b border-gray-100 shrink-0">
            <button onClick={() => setViewReport(null)} className="w-9 h-9 rounded-lg bg-gray-100 flex items-center justify-center text-base active:scale-95">â†</button>
            <span className="text-sm font-bold text-gray-700 truncate max-w-[200px]">{viewReport.title || 'ì œëª© ì—†ìŒ'}</span>
            <button onClick={() => { onEdit(viewReport); }} className="px-3 py-1.5 rounded-lg bg-blue-500 text-white text-xs font-bold active:scale-95">ìˆ˜ì •</button>
          </div>
          <div className="flex-1 overflow-auto p-4">
            <p className="text-[11px] text-gray-400 mb-1">ğŸ“– {viewReport.bookName} Â· {new Date(viewReport.updatedAt).toLocaleDateString('ko-KR')}</p>
            {viewReport.drawingData && (
              <div className="mb-3 rounded-lg overflow-hidden border border-gray-200">
                <img src={viewReport.drawingData} className="w-full" />
              </div>
            )}
            <div className="text-sm text-gray-700 leading-relaxed whitespace-pre-wrap">{viewReport.bodyText || '(ë‚´ìš© ì—†ìŒ)'}</div>
          </div>
        </div>
      )}

      {/* Delete confirmation */}
      {confirmDel && (
        <div className="absolute inset-0 z-50 bg-black/40 flex items-center justify-center">
          <div className="bg-white rounded-2xl p-5 mx-8 shadow-xl">
            <p className="text-sm font-semibold text-gray-700 mb-4">ì´ ê°ìƒë¬¸ì„ ì‚­ì œí• ê¹Œìš”?</p>
            <div className="flex gap-2">
              <button onClick={() => setConfirmDel(null)} className="flex-1 py-2 rounded-lg bg-gray-100 text-sm text-gray-600 font-semibold">ì·¨ì†Œ</button>
              <button onClick={() => handleDelete(confirmDel)} className="flex-1 py-2 rounded-lg bg-red-500 text-sm text-white font-bold">ì‚­ì œ</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LAUNCHER â€” File picker + mode select
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function Launcher({ onSelect }) {
  const pdfRef = useRef(null);
  const [loadingType, setLoadingType] = useState(null);

  const handleFile = (e, type) => {
    const file = e.target.files[0];
    if (!file) return;
    setLoadingType(type);
    const reader = new FileReader();
    reader.onload = () => {
      onSelect(type, reader.result, file.name);
      setLoadingType(null);
    };
    reader.readAsArrayBuffer(file);
    e.target.value = '';
  };

  const modes = [
    { id: 'pdf',   label: 'ë„ì„œ (PDF)', sub: 'Swipe + ë Œë”ë§', icon: 'ğŸ“–', action: () => pdfRef.current.click() },
    { id: 'video', label: 'ì˜ìƒ',        sub: 'Fullscreen',     icon: 'ğŸ¬', action: () => onSelect('video', null, '') },
    { id: 'interactive', label: 'ë†€ì´í•™ìŠµ', sub: 'ì¸í„°ë™í‹°ë¸Œ', icon: 'ğŸ®', action: () => onSelect('interactive', null, 'ë†€ì´í•™ìŠµ ë°ëª¨') },
  ];

  return (
    <div className="w-full h-full flex flex-col items-center justify-center bg-white gap-5 px-8">
      <input ref={pdfRef}  type="file" accept=".pdf"  hidden onChange={e => handleFile(e, 'pdf')} />

      <div className="text-center mb-4">
        <h1 className="text-xl font-bold text-gray-800 tracking-tight">í†µí•© ë·°ì–´ ì—”ì§„ v0.1</h1>
        <p className="text-sm text-gray-400 mt-1">íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”</p>
      </div>

      {loadingType ? (
        <div className="flex flex-col items-center gap-3">
          <div className="w-8 h-8 border-2 border-gray-300 border-t-gray-700 rounded-full animate-spin" />
          <span className="text-sm text-gray-500">íŒŒì¼ ì½ëŠ” ì¤‘...</span>
        </div>
      ) : (
        <div className="flex flex-wrap justify-center gap-4">
          {modes.map(m => (
            <button key={m.id} onClick={m.action}
                    className="w-28 h-32 rounded-2xl border border-gray-200 flex flex-col items-center justify-center gap-2 bg-white hover:bg-gray-50 active:scale-95 transition-all shadow-sm hover:shadow">
              <span className="text-4xl">{m.icon}</span>
              <span className="text-sm font-semibold text-gray-700">{m.label}</span>
              <span className="text-[11px] text-gray-400">{m.sub}</span>
            </button>
          ))}
        </div>
      )}
    </div>
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   APP ROOT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function App() {
  const [mode, setMode] = useState(null);
  const [fileData, setFileData] = useState(null);
  const [fileName, setFileName] = useState('');

  const handleSelect = (type, data, name) => {
    setMode(type);
    setFileData(data);
    setFileName(name);
  };

  const handleExit = () => {
    setMode(null);
    setFileData(null);
    setFileName('');
  };

  if (!mode)                return <Launcher onSelect={handleSelect} />;
  if (mode === 'pdf')       return <PDFBookViewer fileData={fileData} fileName={fileName} onExit={handleExit} />;
  if (mode === 'video')     return <VideoViewer onExit={handleExit} />;
  if (mode === 'interactive') return <InteractiveViewer onExit={handleExit} />;
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
